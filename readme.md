## Створення транзакції
При створенні нової транзакції:

Шукаємо останню транзакцію перед вказаною датою.

Якщо її немає — беремо balance з BankAccount.

Рахуєму balanceAfter для нової транзакції:

balanceAfter = balanceBefore + (±price).

Оновлюємо всі транзакції з date > нової транзакції:

Просто додаємо/віднімаємо її price.

## Варіант з одною sql транзакцією для створення транзакцій(сутність)
- беремо баланс попередньої транзакції (balance_after)

- додаємо/віднімаємо її власну price залежно від type (income чи expense)

- записуємо новий balance_after

Це створює ланцюговий ефект, який гарантує, що кожна транзакція має реалістичний залишок на балансі, заснований на всіх попередніх.

## SQL-запит:
Берем усі транзакції з bank_account_id, де дата більша за дату вставленої/оновленої транзакції.

Для кожної такої транзакції рахуєм кумулятивну суму (через SUM(...) OVER (ORDER BY date ASC ...)), додаючи або віднімаючи price в залежності від типу (income або expense).

Додаємо до цієї суми startingBalance — баланс після оновленої транзакції.

Оновлюєм поле balance_after цих транзакцій на нове значення.

Це означає, що баланси для всіх наступних транзакцій перераховуються коректно, і ми отримуєм послідовність коректних залишків.

## Необхідні покращення

- додати dto з валідацією (наприклад щоб неможливо було створювати транзакції раніше за зараз) 

## Актуальність логіки

Логіка актуальна за умови, що ми рахуємо поточний баланс як реальний баланс на зараз

а не як баланс в наслідок транзакцій, тобто транзакції це дії на майбутнє, які видаляються 

по їх виконанню. 

## Запуск проекта

```
npm install 
```

створити базу postgres, додати .env в корінь проекту

```
npm run start
```